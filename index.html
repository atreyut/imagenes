<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Convertidor de imágenes</title>
    <!-- Librería necesaria para leer HEIC/HEIF en el navegador -->
    <script src="https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js"></script>
</head>
<body>

    <h1>Convertidor y manipulador de imágenes (CPU local)</h1>
    <p>Procesa PNG, JPG, WEBP, HEIC, HEIF.</p>
    <hr>

    <!-- 1. SELECCIÓN DE ARCHIVO -->
    <h3>1. Seleccionar imagen</h3>
    <input type="file" id="inputImage" accept="image/png, image/jpeg, image/webp, image/heic, image/heif">
    <br><br>
    <div id="fileInfo"></div>

    <hr>

    <!-- 2. SELECCIÓN DE FORMATO DE SALIDA -->
    <h3>2. Formato de salida</h3>
    <label for="outputFormat">Convertir a: </label>
    <select id="outputFormat">
        <option value="image/jpeg">JPG / JPEG</option>
        <option value="image/png">PNG</option>
        <option value="image/webp">WEBP</option>
    </select>
    <br>
    <label for="quality">Calidad (0.1 a 1.0, solo JPG/WEBP): </label>
    <input type="number" id="quality" value="0.9" step="0.1" min="0.1" max="1.0" style="width: 50px;">

    <hr>

    <!-- 3. MODO DE OPERACIÓN -->
    <h3>3. Método de transformación</h3>
    <p>Selecciona una opción (son excluyentes):</p>

    <input type="radio" id="modeRatio" name="processMode" value="ratio" checked onchange="toggleSections()">
    <label for="modeRatio"><strong>Modo proporción (aspect ratio)</strong></label>
    <br>
    <input type="radio" id="modePixel" name="processMode" value="pixel" onchange="toggleSections()">
    <label for="modePixel"><strong>Modo dimensiones exactas (px)</strong></label>

    <br><br>

    <!-- SECCIÓN: PROPORCIÓN -->
    <div id="sectionRatio">
        <fieldset>
            <legend>Configuración de proporción</legend>
            <label>Ratio ancho (W): <input type="number" id="ratioW" value="16" style="width: 50px;"></label>
            :
            <label>Ratio alto (H): <input type="number" id="ratioH" value="9" style="width: 50px;"></label>
            <br><br>
            
            <label><strong>Técnica de ajuste:</strong></label><br>
            
            <!-- Opción Crop -->
            <input type="radio" id="fitCrop" name="fitMode" value="crop" checked onchange="toggleFillOptions()">
            <label for="fitCrop">Recortar (crop - quitar sobrantes)</label><br>
            
            <!-- Opción Stretch -->
            <input type="radio" id="fitStretch" name="fitMode" value="stretch" onchange="toggleFillOptions()">
            <label for="fitStretch">Extender (stretch - desproporcionar)</label><br>

            <!-- Opción Fill (Nueva) -->
            <input type="radio" id="fitFill" name="fitMode" value="fill" onchange="toggleFillOptions()">
            <label for="fitFill">Rellenar (fill - completar espacio faltante)</label>

            <!-- Opciones de Relleno (ocultas por defecto) -->
            <div id="fillOptions" style="display: none; margin-left: 20px; margin-top: 10px; border-left: 2px solid #ccc; padding-left: 10px;">
                <p><strong>Configuración de relleno:</strong></p>
                
                <input type="checkbox" id="autoColor" checked onchange="toggleManualColors()">
                <label for="autoColor">Detección automática de color (borde más popular)</label>
                
                <div id="manualColorSection" style="display: none; margin-top: 5px;">
                    <label>Color inicio (Izq / Arr): <input type="color" id="manualColor1" value="#ffffff"></label><br>
                    <label>Color fin (Der / Abj): <input type="color" id="manualColor2" value="#ffffff"></label>
                </div>
            </div>

        </fieldset>
    </div>

    <!-- SECCIÓN: PIXELES -->
    <div id="sectionPixel" style="display: none;">
        <fieldset>
            <legend>Configuración de dimensiones</legend>
            <label>Ancho deseado (px): <input type="number" id="targetWidth" placeholder="Ej. 1920"></label><br>
            <label>Alto deseado (px): <input type="number" id="targetHeight" placeholder="Ej. 1080"></label>
            <br>
            <small>Usa interpolación bicúbica del navegador.</small>
        </fieldset>
    </div>

    <hr>

    <!-- 4. ACCIÓN -->
    <button type="button" onclick="processImage()" style="font-size: 1.2em; cursor: pointer;">Procesar y convertir</button>
    
    <hr>

    <!-- 5. RESULTADO -->
    <h3>Resultados:</h3>
    <div id="status"></div>
    <br>
    <img id="previewImage" alt="Vista previa" style="max-width: 90vw; display: none; border: 1px solid black;">
    <br><br>
    <a id="downloadLink" style="display: none;" download="imagen-convertida">Descargar imagen</a>

    <!-- Canvas oculto para procesamiento -->
    <canvas id="canvas" style="display: none;"></canvas>


    <script>
        // --- LÓGICA DE INTERFAZ ---

        function toggleSections() {
            const isRatio = document.getElementById('modeRatio').checked;
            document.getElementById('sectionRatio').style.display = isRatio ? 'block' : 'none';
            document.getElementById('sectionPixel').style.display = isRatio ? 'none' : 'block';
        }

        function toggleFillOptions() {
            const isFill = document.getElementById('fitFill').checked;
            document.getElementById('fillOptions').style.display = isFill ? 'block' : 'none';
        }

        function toggleManualColors() {
            const isAuto = document.getElementById('autoColor').checked;
            document.getElementById('manualColorSection').style.display = isAuto ? 'none' : 'block';
        }

        // --- LÓGICA DE PROCESAMIENTO ---

        async function processImage() {
            const fileInput = document.getElementById('inputImage');
            const statusDiv = document.getElementById('status');
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const downloadLink = document.getElementById('downloadLink');
            const previewImage = document.getElementById('previewImage');

            // Reset UI
            statusDiv.textContent = "Procesando...";
            downloadLink.style.display = 'none';
            previewImage.style.display = 'none';

            if (fileInput.files.length === 0) {
                statusDiv.textContent = "Error: Por favor selecciona una imagen primero.";
                return;
            }

            const file = fileInput.files[0];
            let imageSource = null;

            try {
                // 1. Cargar imagen (Soporte HEIC)
                if (file.type === "image/heic" || file.type === "image/heif" || file.name.toLowerCase().endsWith('.heic')) {
                    statusDiv.textContent = "Convirtiendo HEIC...";
                    try {
                        const convertedBlob = await heic2any({ blob: file, toType: "image/jpeg" });
                        imageSource = await loadImage(URL.createObjectURL(convertedBlob));
                    } catch (e) {
                        statusDiv.textContent = "Error HEIC. Revisa tu conexión o el archivo.";
                        return;
                    }
                } else {
                    imageSource = await loadImage(URL.createObjectURL(file));
                }

                statusDiv.textContent = "Calculando geometría...";

                // 2. Variables de geometría
                const mode = document.querySelector('input[name="processMode"]:checked').value;
                let finalW, finalH;
                
                // MODO: Pixeles exactos
                if (mode === 'pixel') {
                    finalW = parseInt(document.getElementById('targetWidth').value);
                    finalH = parseInt(document.getElementById('targetHeight').value);
                    if (!finalW || !finalH) throw new Error("Faltan dimensiones.");

                    canvas.width = finalW;
                    canvas.height = finalH;
                    ctx.imageSmoothingQuality = 'high';
                    ctx.drawImage(imageSource, 0, 0, finalW, finalH);
                } 
                // MODO: Proporción
                else {
                    const rW = parseFloat(document.getElementById('ratioW').value);
                    const rH = parseFloat(document.getElementById('ratioH').value);
                    const fitMode = document.querySelector('input[name="fitMode"]:checked').value;

                    if (!rW || !rH) throw new Error("Proporción inválida.");

                    const targetRatio = rW / rH;
                    const sourceRatio = imageSource.width / imageSource.height;

                    // --- SUB-MODO: EXTENDER (Stretch) ---
                    if (fitMode === 'stretch') {
                        finalW = imageSource.width;
                        finalH = Math.round(finalW / targetRatio);
                        canvas.width = finalW;
                        canvas.height = finalH;
                        ctx.drawImage(imageSource, 0, 0, finalW, finalH);
                    }
                    // --- SUB-MODO: RECORTAR (Crop) ---
                    else if (fitMode === 'crop') {
                        let cropW, cropH, srcX, srcY;
                        
                        if (sourceRatio > targetRatio) { // Imagen muy ancha -> Cortar lados
                            cropH = imageSource.height;
                            cropW = Math.round(cropH * targetRatio);
                            srcX = Math.round((imageSource.width - cropW) / 2);
                            srcY = 0;
                        } else { // Imagen muy alta -> Cortar arriba/abajo
                            cropW = imageSource.width;
                            cropH = Math.round(cropW / targetRatio);
                            srcX = 0;
                            srcY = Math.round((imageSource.height - cropH) / 2);
                        }
                        
                        canvas.width = cropW;
                        canvas.height = cropH;
                        ctx.drawImage(imageSource, srcX, srcY, cropW, cropH, 0, 0, cropW, cropH);
                    }
                    // --- SUB-MODO: RELLENAR (Fill) ---
                    else if (fitMode === 'fill') {
                        // Calcular tamaño del lienzo final para contener la imagen completa
                        let drawX = 0, drawY = 0;

                        if (sourceRatio > targetRatio) {
                            // La imagen es más ancha que el destino -> Relleno ARRIBA y ABAJO (Letterbox)
                            // El ancho final es el ancho de la imagen. El alto crece.
                            finalW = imageSource.width;
                            finalH = Math.round(finalW / targetRatio);
                            
                            // Centramos la imagen en Y
                            drawY = Math.round((finalH - imageSource.height) / 2);
                            drawX = 0;

                        } else {
                            // La imagen es más alta que el destino -> Relleno IZQUIERDA y DERECHA (Pillarbox)
                            // El alto final es el alto de la imagen. El ancho crece.
                            finalH = imageSource.height;
                            finalW = Math.round(finalH * targetRatio);

                            // Centramos la imagen en X
                            drawX = Math.round((finalW - imageSource.width) / 2);
                            drawY = 0;
                        }

                        canvas.width = finalW;
                        canvas.height = finalH;

                        // --- LÓGICA DE COLOR DE RELLENO ---
                        let color1, color2; // 1: Inicio (Arr/Izq), 2: Fin (Abj/Der)

                        const isAuto = document.getElementById('autoColor').checked;

                        if (isAuto) {
                            // Crear un canvas temporal pequeño para leer los pixeles sin ensuciar el principal
                            const tmpCanvas = document.createElement('canvas');
                            tmpCanvas.width = imageSource.width;
                            tmpCanvas.height = imageSource.height;
                            const tmpCtx = tmpCanvas.getContext('2d');
                            tmpCtx.drawImage(imageSource, 0, 0);

                            if (sourceRatio > targetRatio) {
                                // Faltan Arriba y Abajo. 
                                // Leer las 2 primeras filas (Arriba) y las 2 últimas (Abajo)
                                color1 = getDominantColor(tmpCtx, 0, 0, imageSource.width, 2); 
                                color2 = getDominantColor(tmpCtx, 0, imageSource.height - 2, imageSource.width, 2);
                            } else {
                                // Faltan Izquierda y Derecha.
                                // Leer las 2 primeras columnas (Izq) y las 2 últimas (Der)
                                color1 = getDominantColor(tmpCtx, 0, 0, 2, imageSource.height);
                                color2 = getDominantColor(tmpCtx, imageSource.width - 2, 0, 2, imageSource.height);
                            }
                        } else {
                            // Colores manuales
                            color1 = document.getElementById('manualColor1').value;
                            color2 = document.getElementById('manualColor2').value;
                        }

                        // Dibujar los rectángulos de fondo primero
                        if (sourceRatio > targetRatio) {
                            // Dibujar Arriba
                            ctx.fillStyle = color1;
                            ctx.fillRect(0, 0, finalW, drawY);
                            // Dibujar Abajo
                            ctx.fillStyle = color2;
                            // +1 pixel para evitar líneas blancas por redondeo
                            ctx.fillRect(0, drawY + imageSource.height - 1, finalW, finalH - (drawY + imageSource.height) + 2);
                        } else {
                            // Dibujar Izquierda
                            ctx.fillStyle = color1;
                            ctx.fillRect(0, 0, drawX, finalH);
                            // Dibujar Derecha
                            ctx.fillStyle = color2;
                            ctx.fillRect(drawX + imageSource.width - 1, 0, finalW - (drawX + imageSource.width) + 2, finalH);
                        }

                        // Finalmente, dibujar la imagen centrada
                        ctx.drawImage(imageSource, drawX, drawY);
                    }
                }

                // 3. Exportar
                const format = document.getElementById('outputFormat').value;
                const quality = parseFloat(document.getElementById('quality').value);
                const dataUrl = canvas.toDataURL(format, quality);

                previewImage.src = dataUrl;
                previewImage.style.display = 'block';

                let ext = format.split('/')[1];
                if(ext === 'jpeg') ext = 'jpg';
                
                downloadLink.href = dataUrl;
                downloadLink.download = `procesada_${Date.now()}.${ext}`;
                downloadLink.textContent = `Descargar imagen (.${ext})`;
                downloadLink.style.display = 'inline-block';
                downloadLink.style.fontSize = "1.5em";

                statusDiv.textContent = "¡Listo!";

            } catch (error) {
                console.error(error);
                statusDiv.textContent = "Error: " + error.message;
            }
        }

        // Función auxiliar para cargar imagen
        function loadImage(src) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = (e) => reject(e);
                img.src = src;
            });
        }

        // Función para obtener el color más popular en un área rectangular
        function getDominantColor(ctx, x, y, w, h) {
            try {
                // Obtener datos de píxeles (RGBA)
                const imgData = ctx.getImageData(x, y, w, h).data;
                const colorCounts = {};
                let maxCount = 0;
                let dominantColor = 'rgb(0,0,0)';

                // Recorrer de 4 en 4 (R, G, B, Alpha)
                for (let i = 0; i < imgData.length; i += 4) {
                    const r = imgData[i];
                    const g = imgData[i + 1];
                    const b = imgData[i + 2];
                    const alpha = imgData[i + 3];

                    // Ignorar pixeles transparentes
                    if (alpha < 10) continue;

                    const key = `${r},${g},${b}`;
                    colorCounts[key] = (colorCounts[key] || 0) + 1;

                    if (colorCounts[key] > maxCount) {
                        maxCount = colorCounts[key];
                        dominantColor = `rgb(${r},${g},${b})`;
                    }
                }
                return dominantColor;
            } catch (e) {
                console.warn("No se pudo detectar color (posible taint del canvas local), usando negro fallback.");
                return '#000000';
            }
        }
    </script>
</body>
</html>
